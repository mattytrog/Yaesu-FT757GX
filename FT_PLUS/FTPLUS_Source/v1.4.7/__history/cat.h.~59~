#ifdef include_cat
int1 command_received = 0;
char temp_byte;
char buffer[40]; 
int8 next_in = 0;

#INT_RDA
void  RDA_isr(VOID)
{
      if(!command_received)
      {
         if(kbhit())
         {
            temp_byte = getc();
            buffer[next_in] = temp_byte;
         
            if(cat_mode == 0)
            {
            if(temp_byte == 0x3B) {next_in = 0;SWITCH_CAT = 1;}
            if(next_in == 4) command_received = 1; else ++next_in;
            
            }
            if(cat_mode == 1)
            {
            if(temp_byte == 0x3B) command_received = 1; else ++next_in;
            if((next_in == 5) && (temp_byte == 0x05)) {next_in = 0; SWITCH_CAT = 1;}
            }
         } 
      }
      //if(SWITCH_CAT) check_cat();
      if(command_received)
      {
         if(kbhit()) {getc();}
         next_in = 0;
      }
clear_interrupt(INT_RDA);
}

INT8 t1 = 0, t2= 0, t3= 0, t4= 0, t5= 0, t6= 0, t7= 0; int32 tmp_val;


   void calc_freq(int1 ifbuffer, int8 state)
   {
      switch(state)
      {
         case 1: tmp_val = storage_buffer[1]; break;
         case 2: if(ifbuffer) tmp_val = storage_buffer[1]; else tmp_val = storage_buffer[2]; break;
         case 3: tmp_val = storage_buffer[3]; break;
         case 4: tmp_val = storage_buffer[4]; break;
      }
      
      if(tmp_val) split_value(tmp_val, t1, t2, t3, t4, t5, t6, t7);
      
      if(ifbuffer)
      {
      ifbuf[5] = 48 + t1;
      ifbuf[6] = 48 + t2;
      ifbuf[7] = 48 + t3;
      ifbuf[8] = 48 + t4;
      ifbuf[9] = 48 + t5;
      ifbuf[10] = 48 + t6;
      ifbuf[11] = 48 + t7;
      }
      else
      {
      cat_ans[5] = 48 + t1;
      cat_ans[6] = 48 + t2;
      cat_ans[7] = 48 + t3;
      cat_ans[8] = 48 + t4;
      cat_ans[9] = 48 + t5;
      cat_ans[10] = 48 + t6;
      cat_ans[11] = 48 + t7;
      }
   }

   VOID calc_if()
   {
      int8 state = get_state();
      ifbuf[0] = 'I';
      ifbuf[1] = 'F';
      
      calc_freq(1, 1);
      IF(mem_channel > 9)
      {
         ifbuf[26] = 48 + 1; //Mem CH first digit(eg 0)in ASCII not HEX
         ifbuf[27] = 48 + (mem_channel - 10); //Mem CH second digit(eg 8)in ASCII not HEX
      }

      ELSE
      {
         ifbuf[26] = 48; //Mem CH first digit(eg 0)in ASCII not HEX
         ifbuf[27] = 48 + (mem_channel); //Mem CH second digit(eg 8)in ASCII not HEX
      }

      IF(cat_tx_transmitting)ifbuf[28]  =('1'); else ifbuf[28] = ('0'); //TX / RX(0 RX, 1 TX)in ASCII
      ifbuf[29] = dummy_mode; //Mode 1 = LSB, 2 = USB, 3 = CW, 4 = FM, 5 = AM, 6 = FSK, 7 = CWN. All dummy values. Should reflect mode change in application
      IF(state == 1){ifbuf[30] = ('0'); ifbuf[32] = ('0'); }//VFO0(VFO A)
      IF(state == 2){ifbuf[30] = ('1'); ifbuf[32] = ('1'); }//VFO1(VFO B)
      ifbuf[31] = ('0'); //Scan(0 = off, 1 = on)
   }
   
   VOID cat_flush(int1 ifbuffer)
   {
      if(ifbuffer)
      {
      for(INT i  = 0; i < 37; i++)
      {
         IF(ifbuf[i] == ';') break;
         ifbuf[i] = '0';
      }
      }
      else
      {
      for(INT i  = 0; i < 25; i++)
      {
         
         cat_ans[i] = '0';
      }
      }
   }

   VOID send_if()
   {
      FOR(INT i  = 0; i < 38; i++)
      {
         putc(ifbuf[i]);
         IF(ifbuf[i] == ';') break;
      }
      
   }

   VOID send_cat()
   {
      for (INT i = 0; i < 24; i++)
      {
         putc(cat_ans[i]);
         IF(cat_ans[i] == ';') break;
      }
      
   }




   INT32 temp_value;

   int32 cat_set_freq(INT8 base)
   {
      
      cat_ans[base] = buffer[5];
      cat_ans[base + 1] = buffer[6];
      cat_ans[base + 2] = buffer[7];
      cat_ans[base + 3] = buffer[8];
      cat_ans[base + 4] = buffer[9];
      cat_ans[base + 5] = buffer[10];
      cat_ans[base + 6] = buffer[11];
      
      join_value(temp_value, cat_ans[base] - 48,cat_ans[base + 1] - 48,cat_ans[base + 2] - 48,
      cat_ans[base + 3] - 48,cat_ans[base + 4] - 48,cat_ans[base + 5] - 48,cat_ans[base + 6] - 48);
      
      
      RETURN temp_value;
   }

   VOID AI_switch()
   {
      IF(buffer[2] == '0') AI = 0;
      IF(buffer[2] == '1') AI = 1;
   }

   void FA_read()
   {
      cat_flush(0);
      calc_freq(0, 1);
      cat_ans[0] = 'F';
      cat_ans[1] = 'A';
      cat_ans[13] = ';';
      send_cat();
   }

   
   void FB_read()
   {
      cat_flush(0);
      calc_freq(0, 2);
      cat_ans[0] = 'F';
      cat_ans[1] = 'B';
      cat_ans[13] = ';';
      send_cat();
   }

   void FA_set()
   {
      cat_flush(0);
      temp_value = cat_set_freq(5); 
      storage_buffer[1] = temp_value; 
      FA_read();

   }
   void FB_set()
   {
      cat_flush(0);
      temp_value = cat_set_freq(5); 
      storage_buffer[2] = temp_value; 
      FB_read();

   }
   
   void FR_read()
   {
//!      cat_flush(0);
//!      cat_ans[0] = 'F';
//!      cat_ans[1] = 'R';
//!      switch(get_state())
//!      {
//!         case 1: cat_ans[2] = '0'; break;
//!         case 2: cat_ans[2] = '1'; break;
//!      }
//!      cat_ans[3] = ';';
//!      send_cat();
   }


   void FT_read()
   {
//!      cat_flush(0);
//!      cat_ans[0] = 'F';
//!      cat_ans[1] = 'T';
//!      switch(get_state())
//!      {
//!         case 1: cat_ans[2] = '0'; break;
//!         case 2: cat_ans[2] = '1'; break;
//!      }
//!      cat_ans[3] = ';';
//!      send_cat();
   }

   void FR_set()
   {
//!      cat_flush(0);
//!      switch(buffer[2])
//!      {
//!         case '0': set_state(1); break;
//!         case '1': set_state(2); break;
//!      }
//!      cat_ans[0] = 'F';
//!      cat_ans[1] = 'R';
//!      switch(get_state())
//!      {
//!         case 1: cat_ans[2] = '0'; break;
//!         case 2: cat_ans[2] = '1'; break;
//!      }
//!      cat_ans[3] = ';';
//!      send_cat();
   }
   
   void FT_set()
   {
//!      cat_flush(0);
//!      switch(buffer[2])
//!      {
//!         case '0': set_state(1); break;
//!         case '1': set_state(2); break;
//!      }
//!      cat_ans[0] = 'F';
//!      cat_ans[1] = 'T';
//!      switch(get_state())
//!      {
//!         case 1: cat_ans[2] = '0'; break;
//!         case 2: cat_ans[2] = '1'; break;
//!      }
//!      cat_ans[3] = ';';
//!      send_cat();
   }


//!   VOID FX_ans(int1 T, int1 vfo)
//!   {
//!      cat_ans[0] = 'F';
//!      if(!T) cat_ans[1] = 'R'; else cat_ans[1] = 'T';
//!      IF(vfo == 0) cat_ans[2] = '0'; else cat_ans[2] = '1';
//!      cat_ans[3] = ';';
//!      send_cat();
//!   }
//!   
//!
//!
//!   VOID FRT_set(int1 T)
//!   {
//!      cat_flush(0);
//!
//!      IF(buffer[2] == '0')
//!      {
//!         IF(active_vfo == 1)save_band_vfo_f(1, band, storage_buffer[1]);
//!         active_vfo = 0; save8(vfo_n,0);
//!         if(!T) FX_ans(0,0); else FX_ans(1,0);
//!      }
//!
//!      IF(buffer[2] == '1')
//!      {
//!         IF(active_vfo == 0)save_band_vfo_f(0, band, storage_buffer[0]);
//!         active_vfo = 1; save8(vfo_n,1);
//!         if(!T) FX_ans(0,1); else FX_ans(1,1);
//!      }
//!   }
//!   
//!  
//!
//!   VOID FRT_read(int1 T)
//!   {
//!      cat_flush(0);
//!      if(!T)
//!      {
//!      IF(active_vfo == 0)FX_ans(0,0);
//!      IF(active_vfo == 1)FX_ans(0,1);
//!      }
//!      else
//!      {
//!      IF(active_vfo == 0) FX_ans(1,0);
//!      IF(active_vfo == 1) FX_ans(1,1);
//!      }
//!   }

   VOID LK_ans(int8 res)
   {
      cat_ans[0] = 'L';
      cat_ans[1] = 'K';
      IF(res == 0) cat_ans[2] = '0'; else cat_ans[2] = '1';
      cat_ans[3] = ';';
      send_cat();
   }

   VOID LK_set()
   {
      cat_flush(0);

      IF(buffer[2] == '0')
      {
         dl = 0;
         LK_ans(0);
      }

      IF(buffer[2] == '1')
      {
         dl = 1;
         LK_ans(1);
      }

      dcs = get_dcs();
   }

   VOID LK_read()
   {
      cat_flush(0);

      IF( ! dl)
      {
         LK_ans(0);
      }

      IF(dl)
      {
         LK_ans(1);
      }
   }

   VOID ID_read()
   {
      IF(id_enable)
      {
         cat_flush(0);
         cat_ans[0] = idbuf[0];
         cat_ans[1] = idbuf[1];
         cat_ans[2] = idbuf[2];
         cat_ans[3] = idbuf[3];
         cat_ans[4] = idbuf[4];
         cat_ans[5] = ';';
         send_cat();
      }
   }

   VOID IE_set()
   {
      IF (buffer[2] == '0') id_enable = 0;
      IF (buffer[2] == '1') id_enable = 1;
      save8(id_enable_n,id_enable);
      beep();
   }

   VOID cat_transmit(int1 tx_request);

   INT8 parse_cat_command_kenwood ()
   {
      INT32 temp_value;
      INT8 report_back = 0;
      INT i;

      //AI DNUP FAFB FN ID IF LK MC MD MR MW RC RDRU RT RXTX SC SP
      INT8 res = 0;
      
      FOR(i  = 0; i < 31; i++)
      {
         IF((buffer[0]  == cat_comm[(i * 4)])&&(buffer[1] == cat_comm[(i * 4) + 1])&&(buffer[cat_comm[(i * 4) + 2]] == ';'))
         {res = cat_comm[(i * 4) + 3]; BREAK; }
      }

      
      SWITCH(res)
      {
         //all no answer
         CASE 1: ID_read(); break; //ID
         case 2: AI_SWITCH(); break;
         CASE 3: btn_dn_handler(0); report_back = 1; break;
         CASE 4: btn_up_handler(0); report_back = 1; break;
         CASE 5: FA_read(); break;
         CASE 6: FB_read(); break;
         CASE 7: FA_set(); report_back = 1; break;
         CASE 8: FB_set(); report_back = 1; break;
         case 9: mode_SWITCH_kenwood(buffer[2]); report_back = 1; break; //FN
         CASE 10: FR_set(); report_back = 2;break;
         CASE 11: FR_read(); break;
         CASE 12: FT_set(); report_back = 2;break;
         CASE 13: FT_read(); break;
         case 14: calc_IF(); send_if(); break;
         CASE 15: IE_set(); break;
         CASE 16: LK_read(); break; //LK;
         CASE 17: LK_set(); report_back = 2; break; //LK + 0 or 1;
         CASE 18: break; //MC
         CASE 19: dummy_mode = (buffer[2]); save8(dummy_mode_n,dummy_mode); break;
         CASE 20: temp_value = storage_buffer[active_vfo]; break;
         CASE 21: break; //MW
         CASE 22: break; //Clear clar freq
         CASE 23: break; //Clar freq - 1 or 10
         CASE 24: break; //Clar freq + 1 or 10
         CASE 25: break; //toggle clar on off
         CASE 26: cat_tx_request = 0; cat_transmit(cat_tx_request); break; //set rx mode
         CASE 27: cat_tx_request = 1; cat_transmit(cat_tx_request); break; //set tx mode
         CASE 28: break; //PMS on / off
         CASE 29: break; //split on / off
         case 30: SWITCH_CAT = 1; break;
         
         
      }

      command_received = 0;
      if(report_back) return report_back;
      RETURN 0;
   }

//!   VOID split_button_handler(int8 state);
//!   VOID dial_lock_button_handler();
//!   VOID clarifier_button_handler(int8 state);

   




INT8 parse_cat_command_yaesu ()
   {
      INT32 byte5 = buffer[4];
      INT32 byte4_upper = ((buffer[3] >> 4) & 0xF);
      INT32 byte4_lower = buffer[3] & 0xF;
      INT32 byte3_upper = ((buffer[2] >> 4) & 0xF);
      INT32 byte3_lower = buffer[2] & 0xF;
      INT32 byte2_upper = ((buffer[1] >> 4) & 0xF);
      INT32 byte2_lower = buffer[1] & 0xF;
      INT32 byte1_upper = ((buffer[0] >> 4) & 0xF);
      INT32 byte1_lower = buffer[0] & 0xF;
      
      SWITCH(byte5)
      {
         CASE 0x01: split_button_handler(); beep(); break;
         CASE 0x02: mrvfo_handler(); break;
         CASE 0x03: vfom_handler(); break;
         CASE 0x04: dial_lock_button_handler(); beep(); break;
         CASE 0x05: vfoab_handler(); break;
         CASE 0x06: mvfo_handler(); break;
         CASE 0x07: btn_up_handler(0); beep(); break;
         CASE 0x08: btn_dn_handler(0); beep(); break;
         CASE 0x09: clarifier_button_handler(); beep(); break;
         CASE 0x0A: storage_buffer[get_state()] = ((byte4_lower * 1000000) + (byte3_upper * 100000) + (byte3_lower * 10000) + (byte2_upper * 1000) + (byte2_lower * 100) + (byte1_upper * 10) + byte1_lower); break;
         CASE 0x0B: vfom_swap_handler(); break;
         CASE 0x0F: storage_buffer[get_state()] = ((byte1_upper * 1000000) + (byte1_lower * 100000) + (byte2_upper * 10000) + (byte2_lower * 1000) + (byte3_upper * 100) + (byte3_lower * 10) + byte4_upper); break;
          
         case 0xFC: beep(); IF( ! gen_tx)gen_tx = 1; else gen_tx = 0; break;
         CASE 0xFE: save8 (checkbyte_n, 0xFF); reset_cpu(); break;
         CASE 0xFF: reset_cpu(); break;
         #ifdef include_cb
         case 0xFD: IF(gen_tx)toggle_cb_mode(); break;
         #endif
         
      }

      IF ((byte5 >= 0xE0) && (byte5 <= 0xEE))
      {
         save_mem_ch_f
         ((byte5 - 0xE0),
         (byte4_lower * 1000000) +
         (byte3_upper * 100000) +
         (byte3_lower * 10000) +
         (byte2_upper * 1000) +
         (byte2_lower * 100) +
         (byte1_upper * 10) +
         (byte1_lower));
         errorbeep(3);
      }

      RETURN 1;
   }

int8 check_cat()
   {
         int8 catres = 0;
         IF (cat_mode == 0)
         {
            IF (command_received) {catres = parse_cat_command_yaesu ();}
        
         }

         
         IF (cat_mode == 1)
         {
            IF (command_received){catres = parse_cat_command_kenwood ();}
         
         }

         if (SWITCH_CAT == 1)
         {
            IF (cat_mode == 0)cat_mode = 1; else cat_mode = 0;
            save8(cat_mode_n,cat_mode) ;
            beep () ;
            if(cat_mode == 1) {calc_if(); send_if();}
            SWITCH_CAT = 0;
         }
         
         if(catres)
         
         {
               command_received = 0;
               return catres;
         } else return 0;
         
   
   }
 
      #endif

